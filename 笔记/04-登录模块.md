## 路由-拦截登录

* 导航守卫 => 路由发生变化的时候 就会触发导航守卫
* 确定要拦截的页面 /user  个人中心  /user/chat    /user/profile

`src/router.js`

```js
import router from '@/router'
```

```js
// 路由的拦截  => 导航守卫
import router from '@/router' // 引入路由实例
import store from '@/store' // 引入store
// 前置守卫 => 当你的路由发生改变之前触发
// to 到哪里去
// from 从哪里来
// next 函数 => 必须 next() => resolve 这个钩子  => 前面不执行next  => 后面永远不执行
// next(false) // 终止当前的跳转
// next(地址) // 跳到另外一个地址
// next() 放行
router.beforeEach(function (to, from, next) {
  if (to.path.startsWith('/user') && !store.state.user.token) {
    //  拦截 判断有无token  有token => 放行 没有token => 登录
    let toPath = {
      path: '/login',
      query: {
        redirectUrl: to.path // 携带要去的地址到登录页 => 登录成功之后  有了权限 再回到刚才没有权限去的地址
      }
    }
    next(toPath)
  } else {
    next() // 直接放行
  }
})
// 后置守卫
export default router

```

- 地址 `/user` 开头的路径，检查是否登录。
- 如果没有 重定向到  登录页面。

  



## 登录-基础布局

```html
<template>
  <div class='container'>
    <van-nav-bar title="登录" left-arrow @click-left="$router.back()"></van-nav-bar>
    <!-- 手机号  验证码  登录按钮 -->
    <van-cell-group>
      <van-field  label="手机号" placeholder="请输入手机号"></van-field>
      <van-field  label="验证码" placeholder="请输入验证码">
        <!-- slot指定给哪个坑填内容 -->
        <van-button  slot="button" size="small" type="primary">发送验证码</van-button>
      </van-field>
    </van-cell-group>
    <div class='btn-box'>
      <van-button type="info" size="small" round block>登录</van-button>
    </div>
  </div>
</template>

<script>
export default {
  name: 'login'
}
</script>

<style scoped>
   .btn-box {
     padding: 20px;
   }
</style>

```

- 样式

```less
.btn_box{
  padding: 10px;
}
```



## 修改vant主题蓝色

`src/main.js`

```diff
import Vant from 'vant'
-import 'vant/lib/index.css'
+import 'vant/lib/index.less'
```

`根目录/vue.config.js`

```js
module.exports = {
  // 覆盖蓝色主题
  css: {
    loaderOptions: {
      less: {
        modifyVars: {
          blue: '#3296fa'
        }
      }
    }
  }
}

```

- vue(脚手架)3.0/4.0  => 默认隐藏了 webpack.config.js => 如果需要需要配置 => 可以在根目录下 新建一个vue.config.js 文件 
- vue.config.js文档文档  https://cli.vuejs.org/zh/config/#css-loaderoptions
- [vant定制主题文档](https://youzan.github.io/vant/#/zh-CN/theme)
- 改了配置文件后，重新启动服务。



## 登录-表单校验

* vue  是为数据为中心
* 校验  => 单个表单校验 => 整体表单校验

- :error-message  绑定 错误信息 属性
  - 有值  显示错误信息。
  - 没有  显示正确，无提示信息。

```html
<van-cell-group>
    <van-field @blur="validMobile" 
               :error-message="errorMsg.mobile" 
               v-model.trim="userForm.mobile"  
               label="手机号" placeholder="请输入手机号" />
    <van-field @blur="validCode" 
               :error-message="errorMsg.code" 
               v-model.trim="userForm.code"  
               label="验证码" placeholder="请输入验证码">
        <van-button class="p10" slot="button" size="mini" type="primary">
            发送验证码
        </van-button>
    </van-field>
</van-cell-group>
<div class="btn_box">
    <van-button type="info" @click="login" block round>登 录</van-button>
</div>
```

- @blur  失去焦点，做校验。

```js
export default {
  name: 'login',
  data () {
    return {
      loginForm: {
        mobile: '13911111111',
        code: '246810'
      },
      // 专门提示信息的
      errMsg: {
        mobile: '',
        code: ''
      }
    }
  },
  methods: {
    checkMobile () {
      //  判断 为空 判断格式
      if (!this.loginForm.mobile) {
        this.errMsg.mobile = '手机号不能为空'
        return false
      }
      // 判断格式
      if (!/^1[3-9]\d{9}$/.test(this.loginForm.mobile)) {
        this.errMsg.mobile = '手机格式不正确'
        return false
      }
      this.errMsg.mobile = '' // 清空信息
      return true
    },
    checkCode () {
      if (!this.loginForm.code) {
        this.errMsg.code = '验证码不能为空'
        return false
      }
      if (!/^\d{6}$/.test(this.loginForm.code)) {
        this.errMsg.code = '验证码必须为6位数字'
        return false
      }
      this.errMsg.code = '' // 清空信息
      return true
    },
    // 登录方法
    login () {
      if (this.checkMobile() && this.checkCode()) {
        // 都通过了 表示前端校验通过 还要调用接口
        // 提示消息 表示登录成功
        console.log('校验通过')
      }
    }
  }
}
```

- 点击登录，整体表单校验。

> 当然也可以使用插件，vee-validate  http://vee-validate.logaretm.com/



## 登录模块-进行登录

- 封装api  `src/api/user.js`
- query参数 => axios  => params
- body 参数  => axios => data

```js
// 用户相关的请求模块
import request from '@/utils/request' // 引入疯转的模块
export function login (data) {
  return request({
    url: '/authorizations',
    data,
    method: 'post'
  }) //  得到一个promise对象  返回
}

```

- 进行登录 `src/views/user/index.vue`

```js
import { login } from '@/api/user'
import { mapMutations } from 'vuex'
```

```js
    ...mapMutations(['updateUser']),
    // 调用登录方法
     // 登录方法
    async login () {
      if (this.checkMobile() && this.checkCode()) {
        // 都通过了 表示前端校验通过 还要调用接口
        // 提示消息 表示登录成功
        const data = await login(this.loginForm) // 获取结果
        // 拿到了token 更新token信息
        // this.$store.commit('updateUser', { user: data }) // 第一种写法
        this.updateUser({ user: data }) // 更新用户信息
        // 登录成功
        this.$gnotify({ type: 'success', message: '登录成功' })
        // 跳转
        // 两种情况 1 redirectUrl (登录未遂 => 登录  => 遂) 2 没有 redirectUrl 跳到首页
        let { redirectUrl } = this.$route.query // 解构当前的路由信息
        this.$router.push(redirectUrl || '/') // 短路表达式
      }
    },
```

* this.$notify能够调用到 方法  => 是因为 Vue.proptotpe.$notify挂载了一个提示方法 
* 教你一招 , 封装 别人的方法

```js
Vue.prototype.$gnotify = (params) => Vue.prototype.$notify({ duration: 800, ...params }) // 小伎俩

```

