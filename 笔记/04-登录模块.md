## 路由-拦截登录

* 导航守卫 => 路由发生变化的时候 就会触发导航守卫

> 确定要拦截的页面

/user  个人中心  /user/chat    /user/profile

>  为什么只拦截这三个页面 

因为我们做的是移动端产品,不是后台管理系统

> 拉新: 吸引用户 ,  不要让用户失望, 所以说除了必要的几个页面,其他的都不强制用户 登录

在permisstion 目录新建 index.js

```js
/****
 *  在此文件中做 导航守卫
 * *****/
import router from '@/router' // 引入路由实例
import store from '@/store' // 引入store对象
// 前置守卫
//  每当路由发生变化时 前置守卫就会执行
router.beforeEach(function (to, from, next) {
//   需要判断你的请求地址 和你的token
// 如果是 /user为起始 说明 需要进行token的判断
  if (to.path.startsWith('/user') && !store.state.user.token) {
    //   需要拦截请求 让它去登录
  //  next('/login')  如果你想去A  被 拦截了 去了登录, 登录成功应该回到你想去的A
    next({
      path: '/login', // 要跳转的地址
      query: {
        // fullpath 和 path  的区别是 fullPath 会带 ?后面的参数 是一个完整的路径
        redirectUrl: to.fullPath // 告诉登录页 我没有完成 访问 你登录之后 一定要帮我完成
      }
    })
  } else {
    // 一种是 地址不是 /user起始  一种是 /user起始 并且token存在
    next() // 直接放行
  }
})

```

- 地址 `/user` 开头的路径，检查是否登录。
- 如果没有 重定向到  登录页面。

  



## 登录-基础布局

```html
<template>
    <div class='container'>
    <!-- 导航 显示返回箭头-->
    <!-- click-left点击左侧事件 -->
    <!-- $router.go(-1) $router.back() -->
    <van-nav-bar title='登录'  left-arrow @click-left="$router.back()"></van-nav-bar>
    <!-- 登录布局 -->
    <!-- 外层需要用cell-group组件来包裹提供 边框 -->
    <van-cell-group>
        <!-- 登录手机号 -->
          <van-field label="手机号"  placeholder="请输入手机号"></van-field>
        <!-- 验证码 -->
          <van-field label="验证码"  placeholder="请输入验证码">
            <!-- 插槽内容 -->
              <van-button slot="button" size="small" type="primary">发送验证码</van-button>
          </van-field>
    </van-cell-group>
    <!-- 登录按钮 -->
    <div class='login-box'>
      <van-button type="info" round size="small" block>登录</van-button>
    </div>
  </div>
</template>

<script>
export default {

}
</script>

<style>
.login-box {
  padding: 20px
}
</style>

```



## 修改vant主题蓝色

`src/main.js`

```diff
import Vant from 'vant'
-import 'vant/lib/index.css'
+import 'vant/lib/index.less'
```

`根目录/vue.config.js`

```js
module.exports = {
  // 覆盖蓝色主题
  css: {
    loaderOptions: {
      less: {
        modifyVars: {
          blue: '#3296fa'
        }
      }
    }
  }
}

```

- vue(脚手架)3.0/4.0  => 默认隐藏了 webpack.config.js => 如果需要需要配置 => 可以在根目录下 新建一个vue.config.js 文件 
- vue.config.js文档文档  https://cli.vuejs.org/zh/guide/css.html#css-modules
- [vant定制主题文档](https://youzan.github.io/vant/#/zh-CN/theme)
- 改了配置文件后，重新启动服务。



## 登录-表单校验

* vue  是为数据为中心
* 校验  => 单个表单校验 => 整体表单校验

- :error-message  绑定 错误信息 属性
  - 有值  显示错误信息。
  - 没有  显示正确，无提示信息。

```html
<van-cell-group>
    <van-field @blur="validMobile" 
               :error-message="errorMsg.mobile" 
               v-model.trim="userForm.mobile"  
               label="手机号" placeholder="请输入手机号" />
    <van-field @blur="validCode" 
               :error-message="errorMsg.code" 
               v-model.trim="userForm.code"  
               label="验证码" placeholder="请输入验证码">
        <van-button class="p10" slot="button" size="mini" type="primary">
            发送验证码
        </van-button>
    </van-field>
</van-cell-group>
<div class="btn_box">
    <van-button type="info" @click="login" block round>登 录</van-button>
</div>
```

- @blur  失去焦点，做校验。

```js
export default {
  name: 'login',
  data () {
    return {
      loginForm: {
        mobile: '13911111111',
        code: '246810'
      },
      // 专门提示信息的
      errMsg: {
        mobile: '',
        code: ''
      }
    }
  },
  methods: {
    checkMobile () {
      //  判断 为空 判断格式
      if (!this.loginForm.mobile) {
        this.errMsg.mobile = '手机号不能为空'
        return false
      }
      // 判断格式
      if (!/^1[3-9]\d{9}$/.test(this.loginForm.mobile)) {
        this.errMsg.mobile = '手机格式不正确'
        return false
      }
      this.errMsg.mobile = '' // 清空信息
      return true
    },
    checkCode () {
      if (!this.loginForm.code) {
        this.errMsg.code = '验证码不能为空'
        return false
      }
      if (!/^\d{6}$/.test(this.loginForm.code)) {
        this.errMsg.code = '验证码必须为6位数字'
        return false
      }
      this.errMsg.code = '' // 清空信息
      return true
    },
    // 登录方法
    login () {
      if (this.checkMobile() && this.checkCode()) {
        // 都通过了 表示前端校验通过 还要调用接口
        // 提示消息 表示登录成功
        console.log('校验通过')
      }
    }
  }
}
```

- 点击登录，整体表单校验。

> 当然也可以使用插件，vee-validate  http://vee-validate.logaretm.com/



## 登录模块-进行登录

- 封装api  `src/api/user.js`
- query参数 => axios  => params
- body 参数  => axios => data

```js
// 用户相关的请求模块
import request from '@/utils/request' // 引入疯转的模块
export function login (data) {
  return request({
    url: '/authorizations',
    data,
    method: 'post'
  }) //  得到一个promise对象  返回
}

```

- 进行登录 `src/views/user/index.vue`

```js
import { login } from '@/api/user'
import { mapMutations } from 'vuex'
```

```js
    ...mapMutations(['updateUser']),
    // 调用登录方法
     // 登录方法
    async login () {
      if (this.checkMobile() && this.checkCode()) {
        // 都通过了 表示前端校验通过 还要调用接口
        // 提示消息 表示登录成功
        const data = await login(this.loginForm) // 获取结果
        // 拿到了token 更新token信息
        // this.$store.commit('updateUser', { user: data }) // 第一种写法
        this.updateUser({ user: data }) // 更新用户信息
        // 登录成功
        this.$gnotify({ type: 'success', message: '登录成功' })
        // 跳转
        // 两种情况 1 redirectUrl (登录未遂 => 登录  => 遂) 2 没有 redirectUrl 跳到首页
        let { redirectUrl } = this.$route.query // 解构当前的路由信息
        this.$router.push(redirectUrl || '/') // 短路表达式
      }
    },
```

* this.$notify能够调用到 方法  => 是因为 Vue.proptotpe.$notify挂载了一个提示方法 
* 教你一招 , 封装 别人的方法

```js
Vue.prototype.$gnotify = (params) => Vue.prototype.$notify({ duration: 800, ...params }) // 小伎俩

```

